require 'cxxproject/buildingblocks/building_block'
require 'cxxproject/buildingblocks/has_libraries_mixin'
require 'cxxproject/buildingblocks/has_sources_mixin'
require 'cxxproject/buildingblocks/has_includes_mixin'
<<<<<<< HEAD
require 'cxxproject/utils/string'
=======
require 'cxxproject/utils/process'
require 'cxxproject/utils/utils'
>>>>>>> Fixed 1.8.6 compatibility, removed transitive_config_deps

module Cxxproject
  class SourceLibrary < BuildingBlock
    include HasLibraries
    include HasSources
    include HasIncludes

    def initialize(name)
      super(name)
    end

    def complete_init()
      if @output_dir_abs
        libs_to_search << @name
        lib_searchpaths << File.join(@output_dir, 'libs')
      else
        libs_with_path << File.join(@output_dir,"lib#{@name}.a")
      end
      super
    end

    def get_archive_name() # relative path
      return @archive_name if @archive_name
      parts = [@output_dir]

      if @output_dir_abs
        parts = [@output_dir_relPath] if @output_dir_relPath
        parts << 'libs'
      end

      parts << "lib#{@name}.a"

      @archive_name = File.join(parts)
      @archive_name
    end

    def get_task_name() # full path
      return @task_name if @task_name

      parts = [@output_dir]
      parts << 'libs' if @output_dir_abs
      parts << "lib#{@name}.a"
      @task_name = File.join(parts)
      @task_name = @project_dir + "/" + @task_name unless @output_dir_abs
      @task_name
    end

    # task that will link the given object files to a static lib
    #
    def convert_to_rake()
      object_multitask = prepare_tasks_for_objects()

      archiver = @tcs[:ARCHIVER]

      res = typed_file_task Rake::Task::LIBRARY, get_task_name => object_multitask do
        Dir.chdir(@project_dir) do

<<<<<<< HEAD
          objString = get_object_filenames
          if objString.length > 8000
            ar_arrays = StringUtils.splitString(objString,8000,".o ", 1)
            archs = []
            for i in 1..ar_arrays.length
              cmd = remove_empty_strings_and_join([
                archiver[:COMMAND], # ar
                archiver[:ARCHIVE_FLAGS], # -rc
                archiver[:FLAGS],
                get_archive_name+"_"+i.to_s, # debug/x.a
                ar_arrays[i-1] # debug/src/abc.o debug/src/xy.o
                ])
              show_command(cmd, "Creating #{get_archive_name}, part #{i} of #{ar_arrays.length}")
              process_console_output(catch_output(cmd), @tcs[:ARCHIVER][:ERROR_PARSER])
              check_system_command(cmd)
              archs << get_archive_name+"_"+i.to_s
            end
            objString = archs.join(" ")
          end
          
          cmd = remove_empty_strings_and_join([
            archiver[:COMMAND], # ar
            archiver[:ARCHIVE_FLAGS], # -rc
            archiver[:FLAGS],
            get_archive_name, # debug/x.a
            objString # debug/src/abc.o debug/src/xy.o
          ])
=======
          FileUtils.rm(get_archive_name) if File.exists?(get_archive_name)
          cmd = [archiver[:COMMAND]] # ar
          cmd += archiver[:ARCHIVE_FLAGS].split(" ")
          cmd += archiver[:FLAGS].split(" ") # --all_load
          cmd << get_archive_name # -o debug/x.exe
          cmd += @objects

          if Cxxproject::Utils.old_ruby?
            cmdLine = cmd.join(" ")
            if cmdLine.length > 8000
              inputName = get_archive_name+".tmp"
              File.open(inputName,"wb") { |f| f.write(cmd[1..-1].join(" ")) }
              consoleOutput = `#{archiver[:COMMAND] + " @" + inputName}`
            else
              consoleOutput = `#{cmd.join(" ")}`
            end
          else
            rd, wr = IO.pipe
            cmd << {
             :err=>:out,
             :out=>wr
            }
            sp = spawn(*cmd)
            cmd.pop
            
            consoleOutput = ProcessHelper.readOutput(sp, rd, wr)
          end

>>>>>>> Fixed 1.8.6 compatibility, removed transitive_config_deps
          show_command(cmd, "Creating #{get_archive_name}")
          process_console_output(catch_output(cmd), @tcs[:ARCHIVER][:ERROR_PARSER])
          check_system_command(cmd)
        end
      end
      
      enhance_with_additional_files(res)
      add_output_dir_dependency(get_task_name, res, true)
      
      add_grouping_tasks(get_task_name)

      setup_rake_dependencies(res)
        
     
      return res
    end

    def add_grouping_tasks(archive)
      namespace 'lib' do
        desc archive
        task @name => archive
      end
    end
  end
end
